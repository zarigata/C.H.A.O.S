// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █▀▄▀█ █▀▀ █▀ █▀ ▄▀█ █▀▀ █▀▀   █ █▄░█ █▀█ █░█ ▀█▀
 * █░▀░█ ██▄ ▄█ ▄█ █▀█ █▄█ ██▄   █ █░▀█ █▀▀ █▄█ ░█░
 * 
 * [CODEX] Message Input Component
 * 
 * This component provides a rich text input for composing messages,
 * with support for attachments, emojis, and message formatting.
 * 
 * Features:
 * - Auto-resizing input field
 * - Emoji picker
 * - File and image uploads with preview
 * - Typing indicator broadcasting
 * - Attachment previews
 * - Nudge and shake effects
 * - Reply and edit modes
 * - Format shortcuts (markdown support)
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import TextareaAutosize from 'react-textarea-autosize';
import Picker from 'emoji-picker-react';
import { 
  Send,
  Smile,
  Paperclip,
  X,
  Image as ImageIcon,
  Camera,
  Mic,
  Bell,
  Maximize2,
  Edit2,
  CornerUpLeft
} from 'lucide-react';
import { useAuth } from '@/lib/auth';
import { useSocket } from '@/lib/socket';
import { useTauri } from '@/lib/tauri';
import { Message } from '@chatera/shared';
import { useOnClickOutside } from '@/hooks/useOnClickOutside';

interface MessageInputProps {
  recipientId: string;
  conversationId: string;
  replyTo?: Message | null;
  editMessage?: Message | null;
  onCancelReply?: () => void;
  onCancelEdit?: () => void;
}

interface Attachment {
  id: string;
  file: File;
  preview: string;
  type: string;
  uploading: boolean;
  progress: number;
  error?: string;
}

/**
 * [H4X] MESSAGE COMPOSITION COMPONENT
 * 
 * Main input field for creating messages with rich features.
 */
const MessageInput: React.FC<MessageInputProps> = ({
  recipientId,
  conversationId,
  replyTo,
  editMessage,
  onCancelReply,
  onCancelEdit,
}) => {
  const { user } = useAuth();
  const { emit } = useSocket();
  const { isDesktop } = useTauri();
  
  // Input state
  const [message, setMessage] = useState('');
  const [isEmojiPickerOpen, setIsEmojiPickerOpen] = useState(false);
  const [attachments, setAttachments] = useState<Attachment[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [previewExpanded, setPreviewExpanded] = useState(false);
  
  // References
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const emojiPickerRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastTypingEventRef = useRef<number>(0);
  
  // Close emoji picker when clicking outside
  useOnClickOutside(emojiPickerRef, () => {
    setIsEmojiPickerOpen(false);
  });
  
  // Set initial message when editing
  useEffect(() => {
    if (editMessage) {
      setMessage(editMessage.content);
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }
  }, [editMessage]);
  
  // Focus input on mount and when reply changes
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, [replyTo]);
  
  /**
   * [H4X] TYPING INDICATOR
   * 
   * Broadcasts typing events to the server with rate limiting
   */
  const broadcastTypingStatus = useCallback(() => {
    const now = Date.now();
    // Only send typing event every 2 seconds at most
    if (now - lastTypingEventRef.current > 2000) {
      emit('typing', { 
        conversationId, 
        recipientId 
      });
      lastTypingEventRef.current = now;
    }
    
    // Clear any existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set a timeout to clear typing status after 5 seconds
    typingTimeoutRef.current = setTimeout(() => {
      emit('typing:stop', { 
        conversationId, 
        recipientId 
      });
    }, 5000);
  }, [conversationId, recipientId, emit]);
  
  // Cleanup typing timeout on unmount
  useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, []);
  
  /**
   * [H4X] MESSAGE HANDLER FUNCTIONS
   * 
   * Handle various message composition and sending states
   */
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMessage(e.target.value);
    
    // Broadcast typing status if message is not empty
    if (e.target.value.trim()) {
      broadcastTypingStatus();
    } else if (typingTimeoutRef.current) {
      // Stop typing immediately if message is empty
      clearTimeout(typingTimeoutRef.current);
      emit('typing:stop', { 
        conversationId, 
        recipientId 
      });
    }
  };
  
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    // Send message on Enter (without shift for new line)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
    
    // Cancel edit/reply on Escape
    if (e.key === 'Escape') {
      if (editMessage && onCancelEdit) {
        onCancelEdit();
      } else if (replyTo && onCancelReply) {
        onCancelReply();
      }
    }
  };
  
  /**
   * [H4X] ATTACHMENT HANDLERS
   * 
   * Process file uploads with previews and progress tracking
   */
  const handleFileUpload = async (files: FileList | null) => {
    if (!files || files.length === 0) return;
    
    const newAttachments: Attachment[] = [];
    
    // Process each file
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const id = `attachment-${Date.now()}-${i}`;
      let preview = '';
      
      // Generate preview for images
      if (file.type.startsWith('image/')) {
        preview = URL.createObjectURL(file);
      }
      
      newAttachments.push({
        id,
        file,
        preview,
        type: file.type,
        uploading: true,
        progress: 0,
      });
    }
    
    // Add new attachments to state
    setAttachments(prev => [...prev, ...newAttachments]);
    setIsUploading(true);
    
    // Simulate upload progress (in real app, replace with actual upload)
    for (const attachment of newAttachments) {
      simulateFileUpload(attachment.id);
    }
  };
  
  // Simulated file upload with progress updates
  const simulateFileUpload = (attachmentId: string) => {
    let progress = 0;
    
    const interval = setInterval(() => {
      progress += 10;
      
      setAttachments(prev =>
        prev.map(a =>
          a.id === attachmentId
            ? { ...a, progress, uploading: progress < 100 }
            : a
        )
      );
      
      if (progress >= 100) {
        clearInterval(interval);
        setIsUploading(false);
      }
    }, 300);
  };
  
  const removeAttachment = (id: string) => {
    setAttachments(prev => {
      const attachment = prev.find(a => a.id === id);
      
      // Revoke object URL for preview if it exists
      if (attachment && attachment.preview) {
        URL.revokeObjectURL(attachment.preview);
      }
      
      return prev.filter(a => a.id !== id);
    });
  };
  
  /**
   * [H4X] PLATFORM-SPECIFIC CAMERA ACCESS
   * 
   * Handles device camera access differently on desktop and web
   */
  const handleCameraCapture = async () => {
    try {
      if (isDesktop) {
        // Handle Tauri desktop camera access
        const { open } = await import('@tauri-apps/api/dialog');
        const { convertFileSrc } = await import('@tauri-apps/api/tauri');
        
        const selected = await open({
          multiple: false,
          filters: [{ name: 'Images', extensions: ['png', 'jpeg', 'jpg'] }]
        });
        
        if (selected && !Array.isArray(selected)) {
          // TODO: Process the selected file for desktop
          console.log('Selected file:', selected);
          
          // This is a simplification - in a real app you'd read the file
          const fileName = selected.split('\\').pop() || selected;
          
          const newAttachment: Attachment = {
            id: `attachment-${Date.now()}`,
            file: new File([], fileName), // Placeholder
            preview: convertFileSrc(selected),
            type: 'image/jpeg', // Assumed
            uploading: false,
            progress: 100,
          };
          
          setAttachments(prev => [...prev, newAttachment]);
        }
      } else {
        // Web camera access
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        
        // Create a video element to show the stream
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        
        // Create a modal to display the camera view
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'bg-white p-4 rounded-lg max-w-lg w-full';
        
        const title = document.createElement('h3');
        title.className = 'text-lg font-medium mb-2';
        title.textContent = 'Take a Photo';
        
        const videoContainer = document.createElement('div');
        videoContainer.className = 'relative aspect-video bg-black rounded-md overflow-hidden mb-4';
        videoContainer.appendChild(video);
        
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'flex justify-between';
        
        const captureButton = document.createElement('button');
        captureButton.className = 'bg-msn-blue text-white px-4 py-2 rounded-md';
        captureButton.textContent = 'Capture';
        
        const cancelButton = document.createElement('button');
        cancelButton.className = 'bg-msn-gray-200 px-4 py-2 rounded-md';
        cancelButton.textContent = 'Cancel';
        
        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(captureButton);
        
        modalContent.appendChild(title);
        modalContent.appendChild(videoContainer);
        modalContent.appendChild(buttonContainer);
        modal.appendChild(modalContent);
        
        document.body.appendChild(modal);
        
        // Handle capture button click
        captureButton.onclick = () => {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          const ctx = canvas.getContext('2d');
          ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Convert to blob
          canvas.toBlob((blob) => {
            if (blob) {
              const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
              
              const newAttachment: Attachment = {
                id: `attachment-${Date.now()}`,
                file,
                preview: URL.createObjectURL(blob),
                type: 'image/jpeg',
                uploading: false,
                progress: 100,
              };
              
              setAttachments(prev => [...prev, newAttachment]);
            }
            
            // Cleanup
            stream.getTracks().forEach(track => track.stop());
            document.body.removeChild(modal);
          }, 'image/jpeg');
        };
        
        // Handle cancel button
        cancelButton.onclick = () => {
          stream.getTracks().forEach(track => track.stop());
          document.body.removeChild(modal);
        };
      }
    } catch (error) {
      console.error('Camera access error:', error);
      // TODO: Show error to user
    }
  };
  
  /**
   * [H4X] EMOJI PICKER HANDLER
   * 
   * Handles emoji selection with position tracking
   */
  const handleEmojiClick = (emojiData: any) => {
    setMessage(prev => prev + emojiData.emoji);
    setIsEmojiPickerOpen(false);
    
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  /**
   * [H4X] NUDGE FUNCTION
   * 
   * Sends a "nudge" notification that makes the other user's window shake
   */
  const sendNudge = () => {
    if (!user) return;
    
    emit('message:nudge', {
      conversationId,
      recipientId,
      senderId: user.id,
    });
    
    // TODO: Play sound effect here
  };
  
  /**
   * [H4X] MESSAGE SENDER
   * 
   * Processes and sends the message to the server
   */
  const handleSendMessage = () => {
    if ((!message.trim() && attachments.length === 0) || !user) return;
    
    // Check if any attachments are still uploading
    if (isUploading) {
      // TODO: Show warning to user
      return;
    }
    
    // Prepare message attachments
    const messageAttachments = attachments.map(a => ({
      name: a.file.name,
      size: a.file.size,
      type: a.file.type,
      url: a.preview, // In a real app, this would be the uploaded file URL
    }));
    
    // If editing an existing message
    if (editMessage) {
      emit('message:edit', {
        messageId: editMessage.id,
        content: message.trim(),
        conversationId,
        recipientId,
      });
      
      if (onCancelEdit) {
        onCancelEdit();
      }
    } else {
      // Send new message
      emit('message:send', {
        content: message.trim(),
        conversationId,
        recipientId,
        senderId: user.id,
        replyToId: replyTo?.id,
        attachments: messageAttachments,
      });
      
      if (onCancelReply && replyTo) {
        onCancelReply();
      }
    }
    
    // Clear input and attachments
    setMessage('');
    
    // Clean up attachment previews
    attachments.forEach(a => {
      if (a.preview) {
        URL.revokeObjectURL(a.preview);
      }
    });
    setAttachments([]);
    
    // Clear typing indicator
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      emit('typing:stop', { 
        conversationId, 
        recipientId 
      });
    }
    
    // Focus back on input
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  return (
    <div className="border-t border-msn-gray-200 dark:border-msn-gray-700 bg-white dark:bg-msn-gray-800 p-3 flex flex-col">
      {/* Edit/Reply notification bar */}
      <AnimatePresence>
        {(editMessage || replyTo) && (
          <motion.div
            className={`
              p-2 mb-2 rounded-md text-sm flex items-center justify-between
              ${editMessage ? 'bg-msn-blue-light text-msn-blue-dark' : 'bg-msn-gray-100 dark:bg-msn-gray-700'}
            `}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
          >
            <div className="flex items-center">
              {editMessage ? (
                <>
                  <Edit2 size={16} className="mr-2" />
                  <span>Editing message</span>
                </>
              ) : (
                <>
                  <CornerUpLeft size={16} className="mr-2" />
                  <span>
                    Replying to <strong>{replyTo?.sender.displayName}</strong>
                  </span>
                </>
              )}
            </div>
            <button
              onClick={editMessage ? onCancelEdit : onCancelReply}
              className="p-1 hover:bg-msn-gray-200 dark:hover:bg-msn-gray-600 rounded-full"
            >
              <X size={16} />
            </button>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Attachment previews */}
      <AnimatePresence>
        {attachments.length > 0 && (
          <motion.div
            className="mb-2"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <div className="flex justify-between items-center mb-1">
              <h4 className="text-sm font-medium">Attachments ({attachments.length})</h4>
              <div className="flex gap-1">
                <button
                  onClick={() => setPreviewExpanded(!previewExpanded)}
                  className="p-1 text-msn-gray-500 hover:text-msn-gray-700 dark:hover:text-msn-gray-300"
                >
                  <Maximize2 size={14} />
                </button>
              </div>
            </div>
            <div 
              className={`
                flex gap-2 overflow-x-auto pb-2 custom-scrollbar
                ${previewExpanded ? 'flex-wrap max-h-40' : 'flex-nowrap'}
              `}
            >
              {attachments.map(attachment => (
                <div
                  key={attachment.id}
                  className="relative group min-w-[80px] h-20 bg-msn-gray-100 dark:bg-msn-gray-700 rounded-md overflow-hidden"
                >
                  {attachment.uploading ? (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/30 text-white text-sm">
                      {attachment.progress}%
                    </div>
                  ) : (
                    <button
                      onClick={() => removeAttachment(attachment.id)}
                      className="absolute top-1 right-1 p-1 bg-black/50 rounded-full text-white opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <X size={12} />
                    </button>
                  )}
                  
                  {attachment.type.startsWith('image/') ? (
                    <img
                      src={attachment.preview}
                      alt="Attachment preview"
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="flex flex-col items-center justify-center h-full p-2">
                      <Paperclip size={16} className="text-msn-gray-500 mb-1" />
                      <span className="text-xs truncate max-w-full">
                        {attachment.file.name}
                      </span>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Input area */}
      <div className="flex items-end gap-2">
        <div className="flex-1 relative">
          <TextareaAutosize
            ref={inputRef}
            value={message}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            placeholder={`Type a message to ${recipientId}`}
            className="w-full resize-none px-3 py-2 rounded-md border border-msn-gray-200 dark:border-msn-gray-700 bg-msn-gray-50 dark:bg-msn-gray-700 focus:outline-none focus:ring-2 focus:ring-msn-blue min-h-[40px] max-h-[200px]"
            minRows={1}
            maxRows={8}
          />
        </div>
        
        {/* Action buttons */}
        <div className="flex gap-1 pb-1">
          {/* Emoji picker */}
          <div className="relative" ref={emojiPickerRef}>
            <button
              onClick={() => setIsEmojiPickerOpen(!isEmojiPickerOpen)}
              className="p-2 rounded-full hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 text-msn-gray-500"
              title="Add emoji"
            >
              <Smile size={20} />
            </button>
            
            {isEmojiPickerOpen && (
              <div className="absolute bottom-full right-0 mb-2 z-10">
                <Picker
                  onEmojiClick={handleEmojiClick}
                  searchPlaceholder="Search emoji..."
                  previewConfig={{ showPreview: false }}
                />
              </div>
            )}
          </div>
          
          {/* Attachment button */}
          <button
            onClick={() => fileInputRef.current?.click()}
            className="p-2 rounded-full hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 text-msn-gray-500"
            title="Add attachment"
          >
            <Paperclip size={20} />
            <input
              ref={fileInputRef}
              type="file"
              multiple
              className="hidden"
              onChange={(e) => handleFileUpload(e.target.files)}
              accept="image/*,video/*,audio/*,application/pdf"
            />
          </button>
          
          {/* Camera button */}
          <button
            onClick={handleCameraCapture}
            className="p-2 rounded-full hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 text-msn-gray-500"
            title="Take photo"
          >
            <Camera size={20} />
          </button>
          
          {/* Nudge button */}
          <button
            onClick={sendNudge}
            className="p-2 rounded-full hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 text-msn-gray-500"
            title="Send nudge"
          >
            <Bell size={20} />
          </button>
          
          {/* Send button */}
          <button
            onClick={handleSendMessage}
            disabled={(!message.trim() && attachments.length === 0) || isUploading}
            className={`
              p-2 rounded-full transition-colors 
              ${(!message.trim() && attachments.length === 0) || isUploading
                ? 'bg-msn-gray-200 dark:bg-msn-gray-700 text-msn-gray-500'
                : 'bg-msn-blue hover:bg-msn-blue-dark text-white'
              }
            `}
            title="Send message"
          >
            <Send size={20} />
          </button>
        </div>
      </div>
    </div>
  );
};

export default MessageInput;
