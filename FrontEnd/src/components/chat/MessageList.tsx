// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █▀▄▀█ █▀▀ █▀ █▀ ▄▀█ █▀▀ █▀▀   █░░ █ █▀ ▀█▀
 * █░▀░█ ██▄ ▄█ ▄█ █▀█ █▄█ ██▄   █▄▄ █ ▄█ ░█░
 * 
 * [CODEX] Message List Component
 * 
 * This component renders the message history in a conversation,
 * displaying both sent and received messages with appropriate styling.
 * 
 * Features:
 * - Auto-scrolling to newest messages
 * - Message grouping by sender and time
 * - Read receipts and delivery status
 * - Media attachment support
 * - Message reactions
 * - Contextual actions (edit, delete, reply)
 * - "Nudge" animations
 */

import React, { useEffect, useRef, useState } from 'react';
import { format, isToday, isYesterday, isSameDay } from 'date-fns';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Edit2, 
  Trash2, 
  Reply, 
  MoreVertical, 
  Check, 
  CheckCheck,
  Image,
  File,
  Paperclip
} from 'lucide-react';
import { useAuth } from '@/lib/auth';
import { useSocket } from '@/lib/socket';
import { Message, MessageStatus, User } from '@chatera/shared';

interface MessageListProps {
  messages: Message[];
  recipient: User;
  onReply: (message: Message) => void;
  onEdit: (message: Message) => void;
  onDelete: (messageId: string) => void;
}

/**
 * [H4X] STATUS INDICATOR COMPONENT
 * 
 * Shows message delivery/read status with appropriate icons
 */
const MessageStatus: React.FC<{ status: MessageStatus }> = ({ status }) => {
  switch (status) {
    case 'sent':
      return <Check size={14} className="text-msn-gray-500" />;
    case 'delivered':
      return <CheckCheck size={14} className="text-msn-gray-500" />;
    case 'read':
      return <CheckCheck size={14} className="text-msn-blue" />;
    default:
      return null;
  }
};

/**
 * [H4X] MESSAGE TIMESTAMP FORMATTER
 * 
 * Returns formatted time string based on message age
 */
const formatMessageTime = (timestamp: Date): string => {
  if (isToday(timestamp)) {
    return format(timestamp, 'h:mm a');
  } else if (isYesterday(timestamp)) {
    return `Yesterday at ${format(timestamp, 'h:mm a')}`;
  } else {
    return format(timestamp, 'MMM d, yyyy h:mm a');
  }
};

/**
 * [H4X] MESSAGE GROUP COMPONENT
 * 
 * Displays a group of messages from the same sender
 */
const MessageGroup: React.FC<{
  messages: Message[];
  isCurrentUser: boolean;
  showAvatar: boolean;
  onReply: (message: Message) => void;
  onEdit: (message: Message) => void;
  onDelete: (messageId: string) => void;
}> = ({ 
  messages, 
  isCurrentUser, 
  showAvatar,
  onReply,
  onEdit,
  onDelete 
}) => {
  if (!messages.length) return null;
  
  const firstMessage = messages[0];
  const sender = firstMessage.sender;
  
  return (
    <div 
      className={`flex mb-4 ${isCurrentUser ? 'justify-end' : 'justify-start'}`}
    >
      {/* Avatar (only shown for first message in group) */}
      {!isCurrentUser && showAvatar && (
        <div className="mt-1 mr-2">
          <img 
            src={sender.avatar || '/default-avatar.png'} 
            alt={sender.displayName} 
            className="h-8 w-8 rounded-full object-cover"
          />
        </div>
      )}
      
      <div className={`flex flex-col max-w-[70%] ${isCurrentUser ? 'items-end' : 'items-start'}`}>
        {/* Sender name (only shown for first message in group) */}
        {!isCurrentUser && showAvatar && (
          <div className="text-sm font-medium mb-1">
            {sender.displayName}
          </div>
        )}
        
        {/* Message bubbles */}
        <div className="flex flex-col gap-1">
          {messages.map((message) => (
            <MessageBubble 
              key={message.id}
              message={message}
              isCurrentUser={isCurrentUser}
              onReply={onReply}
              onEdit={onEdit}
              onDelete={onDelete}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

/**
 * [H4X] MESSAGE BUBBLE COMPONENT
 * 
 * Individual message bubble with content and actions
 */
const MessageBubble: React.FC<{
  message: Message;
  isCurrentUser: boolean;
  onReply: (message: Message) => void;
  onEdit: (message: Message) => void;
  onDelete: (messageId: string) => void;
}> = ({ 
  message, 
  isCurrentUser,
  onReply,
  onEdit,
  onDelete
}) => {
  const [showActions, setShowActions] = useState(false);
  const [isNudging, setIsNudging] = useState(false);
  
  // Handle nudge animation
  useEffect(() => {
    if (message.nudge) {
      setIsNudging(true);
      const timer = setTimeout(() => {
        setIsNudging(false);
      }, 1000);
      
      return () => clearTimeout(timer);
    }
  }, [message.nudge]);
  
  /**
   * [H4X] DETERMINE MESSAGE BUBBLE STYLE
   * 
   * Sets appropriate styles based on sender and content
   */
  const getBubbleClasses = () => {
    const baseClasses = 'py-2 px-3 rounded-lg relative max-w-full';
    const contentClasses = message.isSystemMessage 
      ? 'bg-msn-gray-200 dark:bg-msn-gray-700 text-center italic' 
      : isCurrentUser 
        ? 'bg-msn-blue text-white' 
        : 'bg-white dark:bg-msn-gray-700 border border-msn-gray-200 dark:border-msn-gray-600';
    
    return `${baseClasses} ${contentClasses}`;
  };
  
  /**
   * [H4X] RENDER MESSAGE CONTENT
   * 
   * Displays different message types appropriately
   */
  const renderMessageContent = () => {
    // Handle different message types
    if (message.isDeleted) {
      return (
        <span className="italic text-msn-gray-500">
          This message was deleted
        </span>
      );
    }
    
    if (message.nudge) {
      return (
        <span className="italic">
          {message.sender.displayName} sent a nudge!
        </span>
      );
    }
    
    // Reply reference
    const hasReplyTo = message.replyToId && message.replyToMessage;
    
    return (
      <>
        {/* Reply reference */}
        {hasReplyTo && (
          <div className={`
            text-xs mb-1 p-1 rounded
            ${isCurrentUser ? 'bg-msn-blue-light text-msn-blue-dark' : 'bg-msn-gray-100 dark:bg-msn-gray-600'}
          `}>
            <div className="flex items-center">
              <Reply size={12} className="mr-1" />
              <span className="font-medium truncate">{message.replyToMessage?.sender.displayName}:</span>
            </div>
            <p className="truncate">{message.replyToMessage?.content}</p>
          </div>
        )}
        
        {/* Message text content */}
        <div>
          {message.content}
        </div>
        
        {/* Attachments */}
        {message.attachments && message.attachments.length > 0 && (
          <div className="mt-2 flex flex-wrap gap-2">
            {message.attachments.map((attachment, index) => (
              <div 
                key={index}
                className="relative group"
              >
                {attachment.type.startsWith('image/') ? (
                  <div className="relative">
                    <img 
                      src={attachment.url} 
                      alt={attachment.name || 'Attachment'}
                      className="max-h-40 max-w-40 rounded-md object-cover"
                    />
                    <div className="absolute bottom-1 right-1 bg-black/70 text-white text-xs px-1 rounded">
                      {Math.round(attachment.size / 1024)} KB
                    </div>
                  </div>
                ) : (
                  <div className="flex items-center p-2 bg-black/10 rounded-md">
                    <File size={20} className="mr-2" />
                    <div>
                      <div className="text-sm font-medium truncate max-w-[120px]">
                        {attachment.name}
                      </div>
                      <div className="text-xs">
                        {Math.round(attachment.size / 1024)} KB
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
        
        {/* Timestamp and read status */}
        <div className={`
          flex items-center gap-1 text-xs mt-1 
          ${isCurrentUser ? 'text-white/70' : 'text-msn-gray-500'}
        `}>
          <span>{formatMessageTime(new Date(message.timestamp))}</span>
          {isCurrentUser && <MessageStatus status={message.status} />}
        </div>
      </>
    );
  };
  
  /**
   * [H4X] BUBBLE ANIMATION CONFIG
   * 
   * Configures animations for message bubbles
   */
  const bubbleAnimation = isNudging ? {
    y: [0, -4, 4, -4, 4, 0],
    x: [0, 4, -4, 4, -4, 0],
    transition: { duration: 0.7 }
  } : {};
  
  return (
    <motion.div 
      className={`group relative ${isCurrentUser ? 'ml-auto' : 'mr-auto'}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ 
        opacity: 1, 
        y: 0,
        ...bubbleAnimation
      }}
      transition={{ duration: 0.2 }}
      onHoverStart={() => setShowActions(true)}
      onHoverEnd={() => setShowActions(false)}
    >
      <div className={getBubbleClasses()}>
        {renderMessageContent()}
      </div>
      
      {/* Message actions */}
      <AnimatePresence>
        {showActions && !message.isSystemMessage && !message.isDeleted && (
          <motion.div 
            className={`
              absolute top-0 flex items-center bg-white dark:bg-msn-gray-800 
              shadow-md rounded-md border border-msn-gray-200 dark:border-msn-gray-600
              ${isCurrentUser ? 'right-full mr-2' : 'left-full ml-2'}
            `}
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            transition={{ duration: 0.1 }}
          >
            <button 
              onClick={() => onReply(message)}
              className="p-1.5 hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 rounded-l-md"
              title="Reply"
            >
              <Reply size={16} />
            </button>
            
            {isCurrentUser && (
              <button 
                onClick={() => onEdit(message)}
                className="p-1.5 hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700"
                title="Edit"
              >
                <Edit2 size={16} />
              </button>
            )}
            
            {(isCurrentUser || message.sender.id === 'currentUser') && (
              <button 
                onClick={() => onDelete(message.id)}
                className="p-1.5 hover:bg-msn-gray-100 dark:hover:bg-msn-gray-700 rounded-r-md"
                title="Delete"
              >
                <Trash2 size={16} />
              </button>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};

/**
 * [H4X] DATE SEPARATOR COMPONENT
 * 
 * Shows date boundaries between messages from different days
 */
const DateSeparator: React.FC<{ date: Date }> = ({ date }) => {
  let display = format(date, 'MMMM d, yyyy');
  
  if (isToday(date)) {
    display = 'Today';
  } else if (isYesterday(date)) {
    display = 'Yesterday';
  }
  
  return (
    <div className="flex items-center my-4">
      <div className="h-px bg-msn-gray-200 dark:bg-msn-gray-700 flex-1" />
      <div className="px-3 text-xs text-msn-gray-500 font-medium">
        {display}
      </div>
      <div className="h-px bg-msn-gray-200 dark:bg-msn-gray-700 flex-1" />
    </div>
  );
};

/**
 * [H4X] MAIN MESSAGE LIST COMPONENT
 * 
 * Renders the complete conversation history
 */
const MessageList: React.FC<MessageListProps> = ({ 
  messages,
  recipient,
  onReply,
  onEdit,
  onDelete
}) => {
  const { user } = useAuth();
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [autoScroll, setAutoScroll] = useState(true);
  const { isConnected } = useSocket();
  
  // Auto-scroll to bottom on new messages
  useEffect(() => {
    if (autoScroll && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, autoScroll]);
  
  // Group messages by sender and proximity
  const getMessageGroups = (): { date: Date; groups: Message[][] }[] => {
    const result: { date: Date; groups: Message[][] }[] = [];
    let currentDate: Date | null = null;
    let currentGroups: Message[][] = [];
    let currentGroup: Message[] = [];
    let lastSenderId: string | null = null;
    let lastTimestamp: number | null = null;
    
    messages.forEach((message) => {
      const messageDate = new Date(message.timestamp);
      const messageDay = new Date(
        messageDate.getFullYear(),
        messageDate.getMonth(),
        messageDate.getDate()
      );
      
      // Check if we need to start a new day
      if (currentDate === null || !isSameDay(currentDate, messageDay)) {
        if (currentDate !== null) {
          // Save the current day's groups
          result.push({
            date: currentDate,
            groups: currentGroups,
          });
        }
        
        // Start a new day
        currentDate = messageDay;
        currentGroups = [];
        currentGroup = [message];
        lastSenderId = message.sender.id;
        lastTimestamp = message.timestamp;
      } else {
        // Within the same day
        const timeDifference = lastTimestamp 
          ? message.timestamp - lastTimestamp 
          : 0;
        
        // Start a new group if sender changed or time gap > 5 mins
        if (
          message.sender.id !== lastSenderId ||
          timeDifference > 5 * 60 * 1000 || 
          message.isSystemMessage
        ) {
          if (currentGroup.length > 0) {
            currentGroups.push([...currentGroup]);
          }
          currentGroup = [message];
        } else {
          // Add to current group
          currentGroup.push(message);
        }
        
        lastSenderId = message.sender.id;
        lastTimestamp = message.timestamp;
      }
    });
    
    // Add the last group and day
    if (currentGroup.length > 0) {
      currentGroups.push(currentGroup);
    }
    
    if (currentDate !== null && currentGroups.length > 0) {
      result.push({
        date: currentDate,
        groups: currentGroups,
      });
    }
    
    return result;
  };
  
  const messageGroups = getMessageGroups();
  
  /**
   * [H4X] SCROLL HANDLER
   * 
   * Detects if user has manually scrolled away from bottom
   */
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
    // If scrolled near bottom (within 100px), enable auto-scroll
    const bottomThreshold = 100;
    const isNearBottom = scrollHeight - scrollTop - clientHeight < bottomThreshold;
    setAutoScroll(isNearBottom);
  };
  
  // If no messages, show empty state
  if (messages.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full p-4">
        <div className="text-center p-4 rounded-lg bg-white dark:bg-msn-gray-800 shadow-sm">
          <h3 className="text-lg font-medium mb-2">No messages yet</h3>
          <p className="text-msn-gray-500 mb-4">
            Send a message to start a conversation with {recipient.displayName}
          </p>
          <div className="h-1 w-16 bg-msn-blue mx-auto rounded-full" />
        </div>
      </div>
    );
  }
  
  return (
    <div 
      className="h-full overflow-y-auto p-4 custom-scrollbar bg-msn-gray-50 dark:bg-msn-gray-900"
      onScroll={handleScroll}
    >
      {/* Connection status warning */}
      {!isConnected && (
        <div className="sticky top-0 z-10 bg-msn-red-light text-msn-red-dark px-3 py-2 rounded-md mb-4 text-sm text-center animate-pulse">
          You are currently offline. Messages will be sent when you reconnect.
        </div>
      )}
      
      {/* Message groups by date */}
      {messageGroups.map((dayGroup, dayIndex) => (
        <div key={dayIndex}>
          <DateSeparator date={dayGroup.date} />
          
          {dayGroup.groups.map((group, groupIndex) => {
            const isCurrentUser = group[0].sender.id === user?.id;
            
            return (
              <MessageGroup
                key={`${dayIndex}-${groupIndex}`}
                messages={group}
                isCurrentUser={isCurrentUser}
                showAvatar={true}
                onReply={onReply}
                onEdit={onEdit}
                onDelete={onDelete}
              />
            );
          })}
        </div>
      ))}
      
      {/* Anchor for auto-scrolling */}
      <div ref={messagesEndRef} />
    </div>
  );
};

export default MessageList;
