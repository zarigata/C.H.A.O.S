// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █▀█ █▀▀ ▄▀█ █░░ ▀█▀ █ █▀▄▀█ █▀▀   █▀▀ █▀█ █▀▄▀█ █▀▄▀█
 * █▀▄ ██▄ █▀█ █▄▄ ░█░ █ █░▀░█ ██▄   █▄▄ █▄█ █░▀░█ █░▀░█
 * 
 * [CODEX] WebSocket Communication Provider
 * 
 * This module provides real-time communication capabilities via
 * Socket.IO for instant messaging, presence updates, typing indicators,
 * and voice/video call signaling.
 * 
 * It manages connection state, reconnection logic, and encrypted
 * communication channels based on user preferences.
 */

import React, { createContext, useContext, useEffect, useState, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';
import { useAuth } from './auth';
import { useTauri } from './tauri';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';
import { EventType } from '@chatera/shared';

// Socket.IO server URL
const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'ws://localhost:3001';

// Types
interface SocketContextType {
  socket: Socket | null;
  isConnected: boolean;
  reconnect: () => void;
  emit: <T = any>(event: string, data: any, callback?: (response: T) => void) => void;
  on: <T = any>(event: EventType | string, callback: (data: T) => void) => void;
  off: (event: EventType | string) => void;
}

// Create context
const SocketContext = createContext<SocketContextType>({
  socket: null,
  isConnected: false,
  reconnect: () => {},
  emit: () => {},
  on: () => {},
  off: () => {},
});

/**
 * [H4X] SOCKET PROVIDER
 * 
 * React context provider for WebSocket communication
 */
export const SocketProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const { user, status, getToken } = useAuth();
  const isOnline = useNetworkStatus();
  const { isDesktop } = useTauri();
  
  // Keep track of event listeners for cleanup
  const listenersRef = useRef<Map<string, Function[]>>(new Map());

  /**
   * [H4X] SOCKET INITIALIZATION
   * 
   * Initialize and configure Socket.IO client with authentication
   */
  const initializeSocket = useCallback(() => {
    if (!user || status !== 'authenticated' || !isOnline) {
      return;
    }

    // Get authentication token
    const token = getToken();
    if (!token) {
      console.error('[SOCKET] Authentication token not available');
      return;
    }

    try {
      // Close existing connection if any
      if (socket) {
        socket.disconnect();
      }

      // Create new socket connection
      const socketInstance = io(SOCKET_URL, {
        auth: { token },
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000,
        transports: ['websocket'],
      });

      // Set up event handlers
      socketInstance.on('connect', () => {
        console.info('[SOCKET] Connected to server');
        setIsConnected(true);
      });

      socketInstance.on('disconnect', (reason) => {
        console.info(`[SOCKET] Disconnected: ${reason}`);
        setIsConnected(false);
      });

      socketInstance.on('connect_error', (error) => {
        console.error('[SOCKET] Connection error:', error);
        setIsConnected(false);
      });

      socketInstance.on('reconnect_attempt', (attempt) => {
        console.info(`[SOCKET] Reconnection attempt ${attempt}`);
      });

      socketInstance.on('reconnect', () => {
        console.info('[SOCKET] Reconnected to server');
        setIsConnected(true);
      });

      socketInstance.on('reconnect_failed', () => {
        console.error('[SOCKET] Failed to reconnect');
        setIsConnected(false);
      });

      // Update socket state
      setSocket(socketInstance);

      // Clean up on unmount
      return () => {
        socketInstance.disconnect();
        setSocket(null);
        setIsConnected(false);
      };
    } catch (error) {
      console.error('[SOCKET] Initialization error:', error);
    }
  }, [user, status, isOnline, getToken]);

  // Initialize socket when user is authenticated
  useEffect(() => {
    if (status === 'authenticated' && user) {
      initializeSocket();
    }

    return () => {
      if (socket) {
        socket.disconnect();
        setSocket(null);
        setIsConnected(false);
      }
    };
  }, [user, status, isOnline, initializeSocket]);

  /**
   * [H4X] PLATFORM-SPECIFIC BEHAVIOR
   * 
   * Handle desktop app-specific socket behavior (background/foreground)
   */
  useEffect(() => {
    if (!isDesktop || !socket) return;

    // For desktop: handle window focus/blur events for presence
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible' && socket && !isConnected) {
        socket.connect();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isDesktop, socket, isConnected]);

  /**
   * [H4X] EMIT FUNCTION
   * 
   * Send events to the server with optional callback
   */
  const emit = useCallback(
    <T extends any>(
      event: string,
      data: any,
      callback?: (response: T) => void
    ) => {
      if (socket && isConnected) {
        socket.emit(event, data, callback);
      } else {
        console.warn(`[SOCKET] Cannot emit '${event}': socket not connected`);
      }
    },
    [socket, isConnected]
  );

  /**
   * [H4X] EVENT LISTENER
   * 
   * Register event listeners with proper cleanup
   */
  const on = useCallback(
    <T extends any>(
      event: EventType | string,
      callback: (data: T) => void
    ) => {
      if (socket) {
        // Store callback in refs for cleanup
        if (!listenersRef.current.has(event)) {
          listenersRef.current.set(event, []);
        }
        listenersRef.current.get(event)?.push(callback);

        // Register with socket
        socket.on(event, callback);
      }
    },
    [socket]
  );

  /**
   * [H4X] REMOVE EVENT LISTENER
   * 
   * Unregister event listeners
   */
  const off = useCallback(
    (event: EventType | string) => {
      if (socket) {
        // Get all callbacks for this event
        const callbacks = listenersRef.current.get(event) || [];
        
        // Remove each callback
        callbacks.forEach((callback) => {
          socket.off(event, callback as any);
        });
        
        // Clear from our refs
        listenersRef.current.delete(event);
      }
    },
    [socket]
  );

  /**
   * [H4X] RECONNECT FUNCTION
   * 
   * Force reconnection to the WebSocket server
   */
  const reconnect = useCallback(() => {
    if (socket) {
      socket.disconnect();
      socket.connect();
    } else {
      initializeSocket();
    }
  }, [socket, initializeSocket]);

  return (
    <SocketContext.Provider
      value={{
        socket,
        isConnected,
        reconnect,
        emit,
        on,
        off,
      }}
    >
      {children}
    </SocketContext.Provider>
  );
};

/**
 * [H4X] SOCKET HOOK
 * 
 * Custom hook for easy access to WebSocket functionality
 */
export const useSocket = () => useContext(SocketContext);
