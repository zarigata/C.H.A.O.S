// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * ███████╗███████╗██████╗ ██╗   ██╗███████╗██████╗     ███████╗███╗   ██╗████████╗██████╗ ██╗   ██╗
 * ██╔════╝██╔════╝██╔══██╗██║   ██║██╔════╝██╔══██╗    ██╔════╝████╗  ██║╚══██╔══╝██╔══██╗╚██╗ ██╔╝
 * ███████╗█████╗  ██████╔╝██║   ██║█████╗  ██████╔╝    █████╗  ██╔██╗ ██║   ██║   ██████╔╝ ╚████╔╝ 
 * ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██╔══╝  ██╔══██╗    ██╔══╝  ██║╚██╗██║   ██║   ██╔══██╗  ╚██╔╝  
 * ███████║███████╗██║  ██║ ╚████╔╝ ███████╗██║  ██║    ███████╗██║ ╚████║   ██║   ██║  ██║   ██║   
 * ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝    ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   
 *
 * [CODEX] ChatEra Server Entry Point
 * 
 * This is the main entry point for the ChatEra backend application.
 * It initializes the Express server, sets up middleware, connects
 * to databases, and starts the WebSocket server for real-time
 * communications.
 * 
 * The architecture follows a modular microservices pattern where each
 * service is contained in its own module and can be scaled independently.
 * 
 * [!] PLATFORM COMPATIBILITY: This server is designed to run on both
 * Windows and Linux systems without modifications. Path operations
 * use cross-platform APIs.
 */

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { rateLimit } from 'express-rate-limit';
import { PrismaClient } from '@prisma/client';
import { createClient } from 'redis';
import fs from 'fs';
import path from 'path';

// Import configuration
import { env, config } from './config/env';

// Import routes
import { setupRoutes } from './routes';

// Import WebSocket service
import { setupSocketIO } from './services/socket';

// Import utility functions
import { setupDirectories, logger } from './utils';

/**
 * [H4X] CORE APPLICATION INITIALIZATION
 * 
 * Main application bootstrapping process that initializes
 * all dependencies and starts the server in sequence
 */
async function bootstrap() {
  try {
    // Create required directories
    setupDirectories();
    
    logger.info('╔═══════════════════════════════════════════════╗');
    logger.info('║        CHATERA SERVER STARTING UP...          ║');
    logger.info('╚═══════════════════════════════════════════════╝');
    logger.info(`[ENV] Running in ${env.NODE_ENV} mode`);
    
    // Initialize Express application
    const app = express();
    
    // Create HTTP server (used by both Express and Socket.IO)
    const server = http.createServer(app);
    
    // Initialize Socket.IO
    const io = new SocketIOServer(server, {
      cors: {
        origin: env.CORS_ORIGIN,
        methods: ['GET', 'POST'],
        credentials: true,
      },
    });
    
    // Initialize database clients
    logger.info('[DB] Connecting to PostgreSQL database...');
    const prisma = new PrismaClient();
    await prisma.$connect();
    logger.info('[DB] PostgreSQL connection established.');
    
    logger.info('[REDIS] Connecting to Redis...');
    const redis = createClient({
      url: env.REDIS_URL,
    });
    
    // Handle Redis connection events
    redis.on('error', (err) => {
      logger.error(`[REDIS] Connection error: ${err}`);
    });
    
    await redis.connect();
    logger.info('[REDIS] Redis connection established.');
    
    // Set up Express middleware
    app.use(cors({
      origin: env.CORS_ORIGIN,
      credentials: true,
    }));
    app.use(helmet());
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    
    // Set up request logging
    if (env.NODE_ENV !== 'production') {
      app.use(morgan('dev'));
    } else {
      // In production, log to file
      const accessLogStream = fs.createWriteStream(
        path.join(config.paths.logs, 'access.log'),
        { flags: 'a' }
      );
      app.use(morgan('combined', { stream: accessLogStream }));
    }
    
    // Set up rate limiting
    const limiter = rateLimit({
      windowMs: config.security.rateLimitWindowMs,
      max: config.security.rateLimitMax,
      standardHeaders: true,
      legacyHeaders: false,
    });
    app.use(limiter);
    
    // Pass database clients to app.locals for use in routes
    app.locals.prisma = prisma;
    app.locals.redis = redis;
    
    // Set up routes
    setupRoutes(app);
    
    // Set up Socket.IO handlers
    setupSocketIO(io, { prisma, redis });
    
    // Health check route
    app.get('/health', (req, res) => {
      res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
    });
    
    // Start server
    const PORT = config.server.port;
    server.listen(PORT, () => {
      logger.info(`╔═══════════════════════════════════════════════╗`);
      logger.info(`║  ChatEra server running on port ${PORT}          ║`);
      logger.info(`╚═══════════════════════════════════════════════╝`);
      logger.info(`[READY] Server is ready to accept connections`);
      
      if (env.NODE_ENV !== 'production') {
        logger.info(`[DEV] API documentation available at http://localhost:${PORT}/api-docs`);
      }
    });
    
    // Handle graceful shutdown
    process.on('SIGTERM', async () => {
      logger.info('[SHUTDOWN] SIGTERM received, shutting down gracefully...');
      await gracefulShutdown(server, prisma, redis);
    });
    
    process.on('SIGINT', async () => {
      logger.info('[SHUTDOWN] SIGINT received, shutting down gracefully...');
      await gracefulShutdown(server, prisma, redis);
    });
    
  } catch (error) {
    logger.error('[FATAL] Failed to start server:', error);
    process.exit(1);
  }
}

/**
 * [H4X] GRACEFUL SHUTDOWN
 * 
 * Cleanly shuts down server and database connections
 * to prevent data corruption and connection leaks
 */
async function gracefulShutdown(
  server: http.Server,
  prisma: PrismaClient,
  redis: ReturnType<typeof createClient>
) {
  try {
    logger.info('[SHUTDOWN] Closing HTTP server...');
    await new Promise<void>((resolve) => {
      server.close(() => resolve());
    });
    
    logger.info('[SHUTDOWN] Closing database connections...');
    await prisma.$disconnect();
    await redis.disconnect();
    
    logger.info('[SHUTDOWN] Shutdown complete.');
    process.exit(0);
  } catch (error) {
    logger.error('[SHUTDOWN] Error during shutdown:', error);
    process.exit(1);
  }
}

// Start the application
bootstrap();
