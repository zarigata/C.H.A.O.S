// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * ▄▀█ █░█ ▀█▀ █░█ █▀▀ █▄░█ ▀█▀ █ █▀▀ ▄▀█ ▀█▀ █ █▀█ █▄░█
 * █▀█ █▄█ ░█░ █▀█ ██▄ █░▀█ ░█░ █ █▄▄ █▀█ ░█░ █ █▄█ █░▀█
 *
 * [CODEX] Authentication Utilities
 * 
 * This module provides authentication and authorization utilities
 * for secure user identity management, JWT token handling, and
 * password hashing using argon2.
 */

import * as argon2 from 'argon2';
import { SignJWT, jwtVerify } from 'jose';
import { env } from '../config/env';
import { logger } from './index';

// JWT token secret as Uint8Array for jose library
const JWT_SECRET = new TextEncoder().encode(env.JWT_SECRET);

// Interface for JWT token payload
interface TokenPayload {
  userId: string;
  username: string;
  email: string;
  iat?: number;
  exp?: number;
}

/**
 * [H4X] PASSWORD HASHING
 * 
 * Hashes a password using Argon2id, the recommended algorithm
 * for password hashing that provides robust security against
 * side-channel attacks and GPU cracking.
 */
export async function hashPassword(password: string): Promise<string> {
  try {
    return await argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 65536, // 64 MiB
      timeCost: 3, // 3 iterations
      parallelism: 4,
      saltLength: 16,
    });
  } catch (error) {
    logger.error('[AUTH] Error hashing password:', error);
    throw new Error('Password hashing failed');
  }
}

/**
 * [H4X] PASSWORD VERIFICATION
 * 
 * Verifies a password against its hash using Argon2id.
 */
export async function verifyPassword(
  hashedPassword: string,
  plainTextPassword: string
): Promise<boolean> {
  try {
    return await argon2.verify(hashedPassword, plainTextPassword);
  } catch (error) {
    logger.error('[AUTH] Error verifying password:', error);
    return false;
  }
}

/**
 * [H4X] JWT TOKEN GENERATION
 * 
 * Creates a JWT token for authenticated users with proper expiration
 * and claims.
 */
export async function generateToken(payload: TokenPayload): Promise<string> {
  try {
    // Default token expiration time from env config
    const expiresIn = env.JWT_EXPIRES_IN || '7d';
    
    // Convert expiration to seconds for jose
    let expSeconds = 7 * 24 * 60 * 60; // Default: 7 days
    
    if (typeof expiresIn === 'string') {
      const match = expiresIn.match(/^(\d+)([smhd])$/);
      if (match) {
        const value = parseInt(match[1], 10);
        const unit = match[2];
        
        switch (unit) {
          case 's': expSeconds = value; break;
          case 'm': expSeconds = value * 60; break;
          case 'h': expSeconds = value * 60 * 60; break;
          case 'd': expSeconds = value * 24 * 60 * 60; break;
        }
      }
    }
    
    // Create JWT with jose library
    const token = await new SignJWT({
      userId: payload.userId,
      username: payload.username,
      email: payload.email,
    })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(`${expSeconds}s`)
      .sign(JWT_SECRET);
    
    return token;
  } catch (error) {
    logger.error('[AUTH] Error generating token:', error);
    throw new Error('Failed to generate authentication token');
  }
}

/**
 * [H4X] JWT TOKEN VERIFICATION
 * 
 * Verifies a JWT token and extracts the payload containing user information.
 */
export async function verifyToken(token: string): Promise<TokenPayload | null> {
  try {
    const { payload } = await jwtVerify(token, JWT_SECRET, {
      algorithms: ['HS256'],
    });
    
    return payload as TokenPayload;
  } catch (error) {
    if (error.code === 'ERR_JWT_EXPIRED') {
      logger.debug('[AUTH] Token expired');
      return null;
    }
    
    logger.error('[AUTH] Error verifying token:', error);
    return null;
  }
}

/**
 * [H4X] OAUTH2 CALLBACK STATE VERIFICATION
 * 
 * Creates and verifies state parameters for OAuth2 flows to
 * prevent CSRF attacks during OAuth2 callbacks.
 */
export function generateOAuthState(userId: string): string {
  const crypto = require('crypto');
  const state = crypto.randomBytes(24).toString('hex');
  
  // Store state in Redis with userId for verification
  // Implement this based on your specific Redis setup
  
  return state;
}

/**
 * [H4X] TOKEN REFRESH UTILITY
 * 
 * Refreshes an expired token if the refresh token is valid.
 */
export async function refreshToken(refreshToken: string): Promise<string | null> {
  try {
    // Verify refresh token from database or Redis
    // This is a placeholder - implement based on your refresh token strategy
    
    // If valid, generate new access token
    // const user = getUserFromRefreshToken(refreshToken);
    // return generateToken({ userId: user.id, username: user.username, email: user.email });
    
    return null;
  } catch (error) {
    logger.error('[AUTH] Error refreshing token:', error);
    return null;
  }
}
