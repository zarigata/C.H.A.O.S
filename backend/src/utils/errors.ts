// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █▀▀ █▀█ █▀█ █▀█ █▀█   █░█ ▄▀█ █▄░█ █▀▄ █░░ █ █▄░█ █▀▀
 * ██▄ █▀▄ █▀▄ █▄█ █▀▄   █▀█ █▀█ █░▀█ █▄▀ █▄▄ █ █░▀█ █▄█
 * 
 * [CODEX] Error Handling System
 * 
 * This module provides standardized error handling for the ChatEra
 * application, including custom error classes, middleware for Express,
 * and utility functions for creating consistent error responses.
 */

import { Request, Response, NextFunction } from 'express';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { logger } from './index';
import { env } from '../config/env';

// Standard HTTP status codes for various error types
export enum HttpStatus {
  OK = 200,
  CREATED = 201,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  CONFLICT = 409,
  UNPROCESSABLE_ENTITY = 422,
  INTERNAL_SERVER_ERROR = 500,
  SERVICE_UNAVAILABLE = 503,
}

// Error codes for specific application error scenarios
export enum ErrorCode {
  // Authentication errors
  INVALID_CREDENTIALS = 'auth/invalid-credentials',
  INVALID_TOKEN = 'auth/invalid-token',
  TOKEN_EXPIRED = 'auth/token-expired',
  EMAIL_IN_USE = 'auth/email-in-use',
  USERNAME_TAKEN = 'auth/username-taken',
  
  // Resource errors
  NOT_FOUND = 'resource/not-found',
  ALREADY_EXISTS = 'resource/already-exists',
  INVALID_DATA = 'resource/invalid-data',
  
  // Permission errors
  INSUFFICIENT_PERMISSIONS = 'permission/insufficient',
  ACCESS_DENIED = 'permission/access-denied',
  
  // Rate limiting
  RATE_LIMITED = 'server/rate-limited',
  
  // Server errors
  INTERNAL_ERROR = 'server/internal-error',
  DATABASE_ERROR = 'server/database-error',
  SERVICE_UNAVAILABLE = 'server/service-unavailable',
  
  // Validation errors
  VALIDATION_ERROR = 'validation/error',
  
  // Chat-specific errors
  CHANNEL_NOT_FOUND = 'chat/channel-not-found',
  MEMBER_NOT_FOUND = 'chat/member-not-found',
  NOT_CHANNEL_MEMBER = 'chat/not-channel-member',
}

/**
 * [H4X] APPLICATION ERROR
 * 
 * Custom error class with additional metadata for application errors
 */
export class AppError extends Error {
  code: ErrorCode;
  status: HttpStatus;
  details?: any;
  
  constructor(
    message: string,
    code: ErrorCode = ErrorCode.INTERNAL_ERROR,
    status: HttpStatus = HttpStatus.INTERNAL_SERVER_ERROR,
    details?: any
  ) {
    super(message);
    this.name = 'AppError';
    this.code = code;
    this.status = status;
    this.details = details;
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

/**
 * [H4X] VALIDATION ERROR
 * 
 * Specialized error for validation failures with field-specific details
 */
export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super(
      message,
      ErrorCode.VALIDATION_ERROR,
      HttpStatus.UNPROCESSABLE_ENTITY,
      details
    );
    this.name = 'ValidationError';
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

/**
 * [H4X] UNAUTHORIZED ERROR
 * 
 * Specialized error for authentication failures
 */
export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized', code: ErrorCode = ErrorCode.INVALID_TOKEN) {
    super(message, code, HttpStatus.UNAUTHORIZED);
    this.name = 'UnauthorizedError';
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}

/**
 * [H4X] FORBIDDEN ERROR
 * 
 * Specialized error for permission/authorization failures
 */
export class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden', code: ErrorCode = ErrorCode.ACCESS_DENIED) {
    super(message, code, HttpStatus.FORBIDDEN);
    this.name = 'ForbiddenError';
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, ForbiddenError.prototype);
  }
}

/**
 * [H4X] NOT FOUND ERROR
 * 
 * Specialized error for resource not found
 */
export class NotFoundError extends AppError {
  constructor(message: string = 'Resource not found', resourceType?: string) {
    super(
      resourceType ? `${resourceType} not found` : message,
      ErrorCode.NOT_FOUND,
      HttpStatus.NOT_FOUND
    );
    this.name = 'NotFoundError';
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

/**
 * [H4X] CONFLICT ERROR
 * 
 * Specialized error for resource conflicts (e.g., duplicate entries)
 */
export class ConflictError extends AppError {
  constructor(message: string = 'Resource already exists', details?: any) {
    super(
      message,
      ErrorCode.ALREADY_EXISTS,
      HttpStatus.CONFLICT,
      details
    );
    this.name = 'ConflictError';
    
    // This is needed for proper inheritance in TypeScript
    Object.setPrototypeOf(this, ConflictError.prototype);
  }
}

/**
 * [H4X] ERROR FORMATTER
 * 
 * Creates a standardized error response object
 */
export function formatError(error: any) {
  // For AppErrors, use the existing properties
  if (error instanceof AppError) {
    const response = {
      success: false,
      error: {
        message: error.message,
        code: error.code,
        status: error.status,
      },
    };
    
    // Add details if available and in development mode
    if (error.details && env.NODE_ENV !== 'production') {
      response.error = {
        ...response.error,
        details: error.details,
      };
    }
    
    return response;
  }
  
  // For Prisma errors, provide more specific information
  if (error instanceof PrismaClientKnownRequestError) {
    let code = ErrorCode.DATABASE_ERROR;
    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Database operation failed';
    
    // Map Prisma error codes to our error codes
    switch (error.code) {
      case 'P2002': // Unique constraint failed
        code = ErrorCode.ALREADY_EXISTS;
        status = HttpStatus.CONFLICT;
        
        // Get the field that caused the unique constraint violation
        const target = error.meta?.target as string[] || [];
        message = `A record with this ${target.join(', ')} already exists`;
        break;
        
      case 'P2025': // Record not found
        code = ErrorCode.NOT_FOUND;
        status = HttpStatus.NOT_FOUND;
        message = 'Record not found';
        break;
        
      case 'P2003': // Foreign key constraint failed
        code = ErrorCode.INVALID_DATA;
        status = HttpStatus.BAD_REQUEST;
        message = 'Invalid reference to a non-existent record';
        break;
    }
    
    return {
      success: false,
      error: {
        message,
        code,
        status,
        details: env.NODE_ENV !== 'production' ? {
          databaseError: error.code,
          meta: error.meta,
        } : undefined,
      },
    };
  }
  
  // For regular Errors or unknown objects
  return {
    success: false,
    error: {
      message: error.message || 'An unexpected error occurred',
      code: ErrorCode.INTERNAL_ERROR,
      status: HttpStatus.INTERNAL_SERVER_ERROR,
      stack: env.NODE_ENV !== 'production' && error.stack ? error.stack : undefined,
    },
  };
}

/**
 * [H4X] ERROR MIDDLEWARE
 * 
 * Express middleware to handle errors in a consistent way
 */
export function errorHandler(
  error: any,
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Log the error
  if (error instanceof AppError) {
    if (error.status >= 500) {
      logger.error(`[ERROR] ${error.name}: ${error.message}`, error);
    } else {
      logger.warn(`[ERROR] ${error.name}: ${error.message}`, error);
    }
  } else {
    logger.error('[ERROR] Unhandled exception:', error);
  }
  
  // Format and send the error response
  const formattedError = formatError(error);
  const statusCode = (error instanceof AppError) 
    ? error.status 
    : (error instanceof PrismaClientKnownRequestError && error.code === 'P2025')
      ? HttpStatus.NOT_FOUND
      : HttpStatus.INTERNAL_SERVER_ERROR;
  
  res.status(statusCode).json(formattedError);
}

/**
 * [H4X] NOT FOUND MIDDLEWARE
 * 
 * Express middleware to handle 404 errors for undefined routes
 */
export function notFoundHandler(req: Request, res: Response, next: NextFunction) {
  next(new NotFoundError(`Route not found: ${req.method} ${req.originalUrl}`));
}
