// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * ███████╗███████╗██████╗ ██╗   ██╗███████╗██████╗     ██╗   ██╗████████╗██╗██╗     ███████╗
 * ██╔════╝██╔════╝██╔══██╗██║   ██║██╔════╝██╔══██╗    ██║   ██║╚══██╔══╝██║██║     ██╔════╝
 * ███████╗█████╗  ██████╔╝██║   ██║█████╗  ██████╔╝    ██║   ██║   ██║   ██║██║     ███████╗
 * ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██╔══╝  ██╔══██╗    ██║   ██║   ██║   ██║██║     ╚════██║
 * ███████║███████╗██║  ██║ ╚████╔╝ ███████╗██║  ██║    ╚██████╔╝   ██║   ██║███████╗███████║
 * ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝     ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝
 *                                                                                  
 * [CODEX] Core Server Utilities
 * 
 * This module exports utility functions used throughout the application.
 * It includes facilities for logging, directory management, and other 
 * helper utilities needed for server operations.
 * 
 * Cross-platform compatibility functions ensure that the application
 * works seamlessly on both Windows and Linux environments.
 */

import fs from 'fs';
import path from 'path';
import winston from 'winston';
import { config } from '../config/env';

// Export individual utilities
export * from './auth';
export * from './errors';
export * from './validators';

/**
 * [H4X] LOGGING SYSTEM
 * 
 * Platform-agnostic logger with configurable log levels
 * and appropriate formatting for terminal and file output.
 */
export const logger = winston.createLogger({
  level: config.server.isDevelopment ? 'debug' : 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.printf(({ level, message, timestamp, stack }) => {
      const formattedMessage = stack ? `${message}\n${stack}` : message;
      return `${timestamp} [${level.toUpperCase()}] ${formattedMessage}`;
    })
  ),
  transports: [
    // Log to console in all environments
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ level, message, timestamp, stack }) => {
          const formattedMessage = stack ? `${message}\n${stack}` : message;
          return `${timestamp} [${level.toUpperCase()}] ${formattedMessage}`;
        })
      ),
    }),
  ],
});

// Add file transport in production environment
if (config.server.isProduction) {
  logger.add(
    new winston.transports.File({
      filename: path.join(config.paths.logs, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  
  logger.add(
    new winston.transports.File({
      filename: path.join(config.paths.logs, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
}

/**
 * [H4X] DIRECTORY SETUP
 * 
 * Creates necessary directories for the application
 * with platform-aware path handling.
 */
export function setupDirectories(): void {
  const dirs = [
    config.paths.uploads,
    config.paths.temp,
    config.paths.logs,
  ];
  
  for (const dir of dirs) {
    if (!fs.existsSync(dir)) {
      try {
        // Create directory with recursive option
        fs.mkdirSync(dir, { recursive: true });
        logger.info(`Created directory: ${dir}`);
      } catch (error) {
        logger.error(`Failed to create directory: ${dir}`, error);
      }
    }
  }
}

/**
 * [H4X] PLATFORM DETECTION
 * 
 * Determines the current operating system platform.
 * Used for platform-specific behaviors in file system operations.
 */
export function getPlatform(): 'windows' | 'linux' | 'macos' | 'unknown' {
  const platform = process.platform;
  
  if (platform === 'win32') return 'windows';
  if (platform === 'linux') return 'linux'; 
  if (platform === 'darwin') return 'macos';
  
  return 'unknown';
}

/**
 * [H4X] FILE SIZE FORMATTER
 * 
 * Formats file sizes in human-readable format.
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * [H4X] SAFE JSON PARSE
 * 
 * Safely parses JSON without throwing exceptions.
 */
export function safeJsonParse<T>(json: string, fallback: T): T {
  try {
    return JSON.parse(json) as T;
  } catch (error) {
    logger.error('Failed to parse JSON:', error);
    return fallback;
  }
}

/**
 * [H4X] ASYNC HANDLER
 * 
 * Wraps async route handlers to handle exceptions
 * without need for try/catch blocks in every handler.
 */
export function asyncHandler(fn: Function) {
  return (req: any, res: any, next: any) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * [H4X] RANDOM STRING GENERATOR
 * 
 * Generates a cryptographically secure random string
 * for various security purposes.
 */
export function generateRandomString(length: number): string {
  const crypto = require('crypto');
  return crypto.randomBytes(Math.ceil(length / 2))
    .toString('hex')
    .slice(0, length);
}

/**
 * [H4X] ACCESS CONTROL
 * 
 * Provides a set of utility functions for ensuring
 * proper access control throughout the application.
 */
export const accessControl = {
  // Ensures the authenticated user is the requested user
  isSelf: (authUserId: string, targetUserId: string): boolean => {
    return authUserId === targetUserId;
  },
  
  // Check if user is a member of the specified channel
  async isChannelMember(userId: string, channelId: string, prisma: any): Promise<boolean> {
    const member = await prisma.channelMember.findUnique({
      where: {
        userId_channelId: {
          userId,
          channelId
        }
      }
    });
    
    return !!member;
  },
  
  // Check if user is a server admin or owner
  async isServerAdmin(userId: string, serverId: string, prisma: any): Promise<boolean> {
    // Check if user is the server owner
    const server = await prisma.server.findUnique({
      where: { id: serverId },
      select: { ownerId: true }
    });
    
    if (server?.ownerId === userId) {
      return true;
    }
    
    // Check if user has admin role
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          where: { serverId },
          select: { permissions: true }
        }
      }
    });
    
    return userRoles.some(userRole => 
      userRole.role.permissions.includes('manage_server')
    );
  }
};
