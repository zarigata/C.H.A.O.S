// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █░█ ▄▀█ █░░ █ █▀▄ ▄▀█ ▀█▀ █▀█ █▀█ █▀
 * ▀▄▀ █▀█ █▄▄ █ █▄▀ █▀█ ░█░ █▄█ █▀▄ ▄█
 * 
 * [CODEX] Data Validation Utilities
 * 
 * This module provides validation functions for various data types
 * used throughout the ChatEra application. It includes utilities for
 * validating user data, messages, channels, and more using Zod schemas
 * from the shared package for consistent validation across backend and frontend.
 */

import { 
  validateUser, 
  validateUserUpdate,
  validateMessage,
  validateMessageUpdate,
  validateChannel,
  validateChannelUpdate,
  validateServer,
  validateServerUpdate,
  formatValidationErrors
} from '@chatera/shared';
import { Request, Response, NextFunction } from 'express';
import { ValidationError } from './errors';

/**
 * [H4X] EXPRESS VALIDATION MIDDLEWARE
 * 
 * Validates request body against a schema and passes
 * validated data to the next middleware or handler.
 * 
 * The validation function should return an object with a success property
 * and either a data property (when successful) or an error property.
 */
export function validateRequest(validationFn: Function) {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = validationFn(req.body);
    
    if (!result.success) {
      const errorMessage = formatValidationErrors(result.error);
      return next(new ValidationError(errorMessage, result.error.format()));
    }
    
    // Replace original body with validated and sanitized data
    req.body = result.data;
    next();
  };
}

/**
 * [H4X] USERNAME VALIDATOR
 * 
 * Checks if a username meets the required format
 */
export function isValidUsername(username: string): boolean {
  // Alphanumeric characters, underscore, and period
  // Between 3 and 30 characters
  const usernameRegex = /^[a-zA-Z0-9_.]{3,30}$/;
  return usernameRegex.test(username);
}

/**
 * [H4X] EMAIL VALIDATOR
 * 
 * Checks if an email address is in a valid format
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * [H4X] PASSWORD STRENGTH VALIDATOR
 * 
 * Checks if a password meets the required strength criteria
 */
export function isStrongPassword(password: string): { valid: boolean; reason?: string } {
  if (password.length < 8) {
    return { valid: false, reason: 'Password must be at least 8 characters long' };
  }
  
  if (!/[A-Z]/.test(password)) {
    return { valid: false, reason: 'Password must contain at least one uppercase letter' };
  }
  
  if (!/[a-z]/.test(password)) {
    return { valid: false, reason: 'Password must contain at least one lowercase letter' };
  }
  
  if (!/[0-9]/.test(password)) {
    return { valid: false, reason: 'Password must contain at least one number' };
  }
  
  if (!/[^A-Za-z0-9]/.test(password)) {
    return { valid: false, reason: 'Password must contain at least one special character' };
  }
  
  return { valid: true };
}

/**
 * [H4X] URL VALIDATOR
 * 
 * Checks if a string is a valid URL
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * [H4X] UUID VALIDATOR
 * 
 * Checks if a string is a valid UUID
 */
export function isValidUuid(uuid: string): boolean {
  const uuidRegex = 
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

/**
 * [H4X] VALIDATION MIDDLEWARE GENERATORS
 * 
 * Factory functions to create validation middleware for different entity types
 */

// User validation middleware
export const validateUserRequest = validateRequest(validateUser);
export const validateUserUpdateRequest = validateRequest(validateUserUpdate);

// Message validation middleware
export const validateMessageRequest = validateRequest(validateMessage);
export const validateMessageUpdateRequest = validateRequest(validateMessageUpdate);

// Channel validation middleware
export const validateChannelRequest = validateRequest(validateChannel);
export const validateChannelUpdateRequest = validateRequest(validateChannelUpdate);

// Server validation middleware
export const validateServerRequest = validateRequest(validateServer);
export const validateServerUpdateRequest = validateRequest(validateServerUpdate);

/**
 * [H4X] CUSTOM VALIDATION MIDDLEWARE
 * 
 * For more complex validations that require additional processing
 * or database queries
 */

// Registration validation middleware
export function validateRegistration() {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { username, email, password } = req.body;
      
      // Validate username
      if (!isValidUsername(username)) {
        throw new ValidationError('Invalid username format', {
          username: 'Username must be 3-30 characters and may contain letters, numbers, underscores, and periods'
        });
      }
      
      // Validate email
      if (!isValidEmail(email)) {
        throw new ValidationError('Invalid email format', {
          email: 'Invalid email address format'
        });
      }
      
      // Validate password strength
      const passwordCheck = isStrongPassword(password);
      if (!passwordCheck.valid) {
        throw new ValidationError('Password not strong enough', {
          password: passwordCheck.reason
        });
      }
      
      // Continue to next middleware or handler
      next();
    } catch (error) {
      next(error);
    }
  };
}

/**
 * [H4X] SANITIZER UTILITIES
 * 
 * Sanitize user input to prevent XSS and other injection attacks
 */

// HTML sanitizer for user-generated content
export function sanitizeHtml(html: string): string {
  // Basic implementation - in production, use a proper HTML sanitizer library
  return html
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// Username sanitizer
export function sanitizeUsername(username: string): string {
  // Remove any characters that don't match our allowed pattern
  return username.replace(/[^a-zA-Z0-9_.]/g, '');
}

/**
 * [H4X] DATA TRANSFORMATION UTILITIES
 * 
 * Transform data between different formats
 */

// Convert string ID to number (for APIs that use numeric IDs)
export function parseId(id: string): number {
  const parsed = parseInt(id, 10);
  if (isNaN(parsed)) {
    throw new ValidationError('Invalid ID format', { id: 'ID must be a number' });
  }
  return parsed;
}

// Format a date to ISO string with validation
export function formatDateISO(date: string | Date): string {
  try {
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    
    if (isNaN(dateObj.getTime())) {
      throw new Error('Invalid date');
    }
    
    return dateObj.toISOString();
  } catch (error) {
    throw new ValidationError('Invalid date format', { date: 'Invalid date format' });
  }
}
