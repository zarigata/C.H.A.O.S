// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * ██████╗ ███████╗ █████╗ ██╗      ████████╗██╗███╗   ███╗███████╗
 * ██╔══██╗██╔════╝██╔══██╗██║      ╚══██╔══╝██║████╗ ████║██╔════╝
 * ██████╔╝█████╗  ███████║██║█████╗   ██║   ██║██╔████╔██║█████╗  
 * ██╔══██╗██╔══╝  ██╔══██║██║╚════╝   ██║   ██║██║╚██╔╝██║██╔══╝  
 * ██║  ██║███████╗██║  ██║███████╗   ██║   ██║██║ ╚═╝ ██║███████╗
 * ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝╚═╝     ╚═╝╚══════╝
 * 
 * [CODEX] WebSocket Service Implementation
 * 
 * This service handles all real-time communication between clients using Socket.IO.
 * It manages presence, typing indicators, message delivery, and call signaling.
 * The implementation is designed for scalability and performance, with Redis
 * pub/sub for multi-server deployments.
 */

import { Server as SocketIOServer, Socket } from 'socket.io';
import { PrismaClient } from '@prisma/client';
import { createClient } from 'redis';
import { verifyToken } from '../utils/auth';
import { logger } from '../utils';
import { env } from '../config/env';
import { EventType } from '@chatera/shared';

// Define dependency interfaces
interface Dependencies {
  prisma: PrismaClient;
  redis: ReturnType<typeof createClient>;
}

// Socket.IO connection handler type
type SocketHandler = (socket: Socket, userId: string) => void;

/**
 * Sets up the Socket.IO server with all event handlers
 */
export function setupSocketIO(io: SocketIOServer, deps: Dependencies): void {
  const { prisma, redis } = deps;
  
  // Redis pub/sub channels
  const REDIS_CHANNEL = 'chatera:events';
  
  // Set up Redis pub/sub for multi-server scaling
  const redisSubscriber = redis.duplicate();
  
  // Subscribe to events channel
  redisSubscriber.subscribe(REDIS_CHANNEL, (message) => {
    try {
      const event = JSON.parse(message);
      // Broadcast to appropriate room
      if (event.roomId) {
        io.to(event.roomId).emit(event.type, event.payload);
      } else {
        io.emit(event.type, event.payload);
      }
    } catch (error) {
      logger.error('[SOCKET] Error processing Redis message:', error);
    }
  });
  
  // Authenticate and handle connections
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      
      if (!token) {
        return next(new Error('Authentication token required'));
      }
      
      const payload = await verifyToken(token);
      
      if (!payload || !payload.userId) {
        return next(new Error('Invalid token'));
      }
      
      // Attach user ID to socket instance
      socket.data.userId = payload.userId;
      next();
    } catch (error) {
      logger.error('[SOCKET] Authentication error:', error);
      next(new Error('Authentication failed'));
    }
  });
  
  // Handle new connections
  io.on('connection', async (socket) => {
    const userId = socket.data.userId;
    
    logger.info(`[SOCKET] User ${userId} connected`);
    
    try {
      // Update user status to online
      await prisma.user.update({
        where: { id: userId },
        data: { 
          status: 'online',
          lastSeen: new Date()
        },
      });
      
      // Join user's personal room for direct messages
      socket.join(`user:${userId}`);
      
      // Get user's channels and join their rooms
      const userChannels = await prisma.channelMember.findMany({
        where: { userId },
        select: { channelId: true },
      });
      
      for (const { channelId } of userChannels) {
        socket.join(`channel:${channelId}`);
      }
      
      // Get user's servers and join their rooms
      const userServers = await prisma.serverMember.findMany({
        where: { userId },
        select: { serverId: true },
      });
      
      for (const { serverId } of userServers) {
        socket.join(`server:${serverId}`);
      }
      
      // Broadcast user online status
      publishEvent({
        type: 'user_status_changed',
        payload: {
          userId,
          status: 'online',
        },
      });
      
      // Set up event handlers
      setupMessageHandlers(socket, userId, deps);
      setupPresenceHandlers(socket, userId, deps);
      setupCallHandlers(socket, userId, deps);
      setupChannelHandlers(socket, userId, deps);
      
      // Handle disconnection
      socket.on('disconnect', async () => {
        logger.info(`[SOCKET] User ${userId} disconnected`);
        
        try {
          // Update user status to offline
          await prisma.user.update({
            where: { id: userId },
            data: { 
              status: 'offline',
              lastSeen: new Date()
            },
          });
          
          // Broadcast user offline status
          publishEvent({
            type: 'user_status_changed',
            payload: {
              userId,
              status: 'offline',
            },
          });
        } catch (error) {
          logger.error(`[SOCKET] Error handling disconnect for user ${userId}:`, error);
        }
      });
    } catch (error) {
      logger.error(`[SOCKET] Error setting up socket for user ${userId}:`, error);
      socket.disconnect(true);
    }
  });
  
  /**
   * Publish an event to Redis for distribution to all servers
   */
  function publishEvent(event: { type: EventType; payload: any; roomId?: string }) {
    redis.publish(REDIS_CHANNEL, JSON.stringify(event)).catch(err => {
      logger.error('[SOCKET] Error publishing to Redis:', err);
    });
  }
}
