// =================================================================
// ██████╗██╗  ██╗ █████╗ ████████╗███████╗██████╗  █████╗ 
// ██╔════╝██║  ██║██╔══██╗╚══██╔══╝██╔════╝██╔══██╗██╔══██╗
// ██║     ███████║███████║   ██║   █████╗  ██████╔╝███████║
// ██║     ██╔══██║██╔══██║   ██║   ██╔══╝  ██╔══██╗██╔══██║
// ╚██████╗██║  ██║██║  ██║   ██║   ███████╗██║  ██║██║  ██║
//  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// GENERATED BY CLAUDE: ChatEra v1.0 – 2025-05-13
// =================================================================

/**
 * █▀▄▀█ █▀▀ █▀ █▀ ▄▀█ █▀▀ █ █▄░█ █▀▀   █░█ ▄▀█ █▄░█ █▀▄ █░░ █▀▀ █▀█ █▀
 * █░▀░█ ██▄ ▄█ ▄█ █▀█ █▄█ █ █░▀█ █▄█   █▀█ █▀█ █░▀█ █▄▀ █▄▄ ██▄ █▀▄ ▄█
 * 
 * [CODEX] Socket.IO Message Event Handlers
 * 
 * This module handles all messaging-related Socket.IO events including:
 * - Sending messages
 * - Editing messages
 * - Deleting messages
 * - Reactions
 * - Typing indicators
 * - Message read status
 */

import { Socket } from 'socket.io';
import { PrismaClient } from '@prisma/client';
import { createClient } from 'redis';
import { logger } from '../../utils';
import { validateMessage, validateMessageUpdate } from '@chatera/shared';

// Define dependency interface
interface Dependencies {
  prisma: PrismaClient;
  redis: ReturnType<typeof createClient>;
}

/**
 * Sets up all message-related event handlers for a socket connection
 */
export function setupMessageHandlers(
  socket: Socket,
  userId: string,
  { prisma, redis }: Dependencies
): void {
  // Message creation event
  socket.on('message:send', async (data, callback) => {
    try {
      // Validate input data
      const validation = validateMessage({
        ...data,
        senderId: userId,
        createdAt: new Date(),
        updatedAt: new Date()
      });
      
      if (!validation.success) {
        return callback?.({
          success: false,
          error: 'Invalid message data'
        });
      }
      
      // Check if user has permission to send messages in this channel
      const isMember = await prisma.channelMember.findUnique({
        where: {
          userId_channelId: {
            userId,
            channelId: data.channelId
          }
        }
      });
      
      if (!isMember) {
        return callback?.({
          success: false,
          error: 'You are not a member of this channel'
        });
      }
      
      // Create message in database
      const message = await prisma.message.create({
        data: {
          content: data.content,
          senderId: userId,
          channelId: data.channelId,
          replyToId: data.replyToId,
          // If attachments provided, create them
          attachments: data.attachments ? {
            createMany: {
              data: data.attachments.map(att => ({
                type: att.type,
                url: att.url,
                filename: att.filename,
                size: att.size,
                width: att.width,
                height: att.height,
                duration: att.duration
              }))
            }
          } : undefined,
          // If mentions provided, create them
          mentions: data.mentions ? {
            createMany: {
              data: data.mentions.map(mention => ({
                mentionedId: mention.id,
                mentionType: mention.type
              }))
            }
          } : undefined
        },
        include: {
          sender: {
            select: {
              id: true,
              username: true,
              displayName: true,
              avatar: true
            }
          },
          attachments: true,
          mentions: true
        }
      });
      
      // Broadcast message to channel members
      socket.to(`channel:${data.channelId}`).emit('message:received', message);
      
      // Publish to Redis for multi-server deployments
      redis.publish('chatera:events', JSON.stringify({
        type: 'message:received',
        roomId: `channel:${data.channelId}`,
        payload: message
      }));
      
      // Update channel's last activity timestamp
      await prisma.channel.update({
        where: { id: data.channelId },
        data: { updatedAt: new Date() }
      });
      
      // Return success to sender
      callback?.({
        success: true,
        message
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error sending message:', error);
      callback?.({
        success: false,
        error: 'Failed to send message'
      });
    }
  });
  
  // Message edit event
  socket.on('message:edit', async (data, callback) => {
    try {
      const { id, content } = data;
      
      // Validate that the message exists and belongs to the user
      const message = await prisma.message.findFirst({
        where: {
          id,
          senderId: userId
        }
      });
      
      if (!message) {
        return callback?.({
          success: false,
          error: 'Message not found or you are not the sender'
        });
      }
      
      // Update message
      const updatedMessage = await prisma.message.update({
        where: { id },
        data: {
          content,
          edited: true,
          updatedAt: new Date()
        },
        include: {
          sender: {
            select: {
              id: true,
              username: true,
              displayName: true,
              avatar: true
            }
          },
          attachments: true,
          mentions: true
        }
      });
      
      // Broadcast edit to channel
      socket.to(`channel:${message.channelId}`).emit('message:updated', updatedMessage);
      
      // Publish to Redis for multi-server deployments
      redis.publish('chatera:events', JSON.stringify({
        type: 'message:updated',
        roomId: `channel:${message.channelId}`,
        payload: updatedMessage
      }));
      
      // Return success
      callback?.({
        success: true,
        message: updatedMessage
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error editing message:', error);
      callback?.({
        success: false,
        error: 'Failed to edit message'
      });
    }
  });
  
  // Message delete event
  socket.on('message:delete', async (data, callback) => {
    try {
      const { id } = data;
      
      // Get message with channel info
      const message = await prisma.message.findFirst({
        where: {
          id,
          senderId: userId
        },
        select: {
          id: true,
          channelId: true,
          channel: {
            select: {
              serverId: true
            }
          }
        }
      });
      
      if (!message) {
        return callback?.({
          success: false,
          error: 'Message not found or you are not the sender'
        });
      }
      
      // Check for admin/mod permissions if it's a server channel
      if (message.channel.serverId) {
        const hasPermission = await checkServerPermission(
          userId,
          message.channel.serverId,
          'manage_messages',
          prisma
        );
        
        // If not sender and not admin/mod, deny
        if (!hasPermission) {
          return callback?.({
            success: false,
            error: 'You do not have permission to delete this message'
          });
        }
      }
      
      // Delete message
      await prisma.message.delete({
        where: { id }
      });
      
      // Broadcast deletion
      socket.to(`channel:${message.channelId}`).emit('message:deleted', {
        id,
        channelId: message.channelId
      });
      
      // Publish to Redis for multi-server deployments
      redis.publish('chatera:events', JSON.stringify({
        type: 'message:deleted',
        roomId: `channel:${message.channelId}`,
        payload: {
          id,
          channelId: message.channelId
        }
      }));
      
      // Return success
      callback?.({
        success: true
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error deleting message:', error);
      callback?.({
        success: false,
        error: 'Failed to delete message'
      });
    }
  });
  
  // Message reaction events
  socket.on('message:react', async (data, callback) => {
    try {
      const { messageId, emoji } = data;
      
      // Verify message exists
      const message = await prisma.message.findUnique({
        where: { id: messageId },
        select: { channelId: true }
      });
      
      if (!message) {
        return callback?.({
          success: false,
          error: 'Message not found'
        });
      }
      
      // Add reaction
      await prisma.messageReaction.upsert({
        where: {
          userId_messageId_emoji: {
            userId,
            messageId,
            emoji
          }
        },
        update: {},
        create: {
          userId,
          messageId,
          emoji
        }
      });
      
      // Get updated reactions count
      const reactions = await prisma.messageReaction.groupBy({
        by: ['emoji'],
        where: { messageId },
        _count: { emoji: true }
      });
      
      const formattedReactions = reactions.reduce((acc, curr) => {
        acc[curr.emoji] = curr._count.emoji;
        return acc;
      }, {} as Record<string, number>);
      
      // Broadcast reaction update
      socket.to(`channel:${message.channelId}`).emit('message:reaction_updated', {
        messageId,
        reactions: formattedReactions
      });
      
      // Publish to Redis
      redis.publish('chatera:events', JSON.stringify({
        type: 'message:reaction_updated',
        roomId: `channel:${message.channelId}`,
        payload: {
          messageId,
          reactions: formattedReactions
        }
      }));
      
      // Return success
      callback?.({
        success: true,
        reactions: formattedReactions
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error adding reaction:', error);
      callback?.({
        success: false,
        error: 'Failed to add reaction'
      });
    }
  });
  
  // Remove reaction
  socket.on('message:unreact', async (data, callback) => {
    try {
      const { messageId, emoji } = data;
      
      // Verify message exists
      const message = await prisma.message.findUnique({
        where: { id: messageId },
        select: { channelId: true }
      });
      
      if (!message) {
        return callback?.({
          success: false,
          error: 'Message not found'
        });
      }
      
      // Remove reaction
      await prisma.messageReaction.delete({
        where: {
          userId_messageId_emoji: {
            userId,
            messageId,
            emoji
          }
        }
      });
      
      // Get updated reactions count
      const reactions = await prisma.messageReaction.groupBy({
        by: ['emoji'],
        where: { messageId },
        _count: { emoji: true }
      });
      
      const formattedReactions = reactions.reduce((acc, curr) => {
        acc[curr.emoji] = curr._count.emoji;
        return acc;
      }, {} as Record<string, number>);
      
      // Broadcast reaction update
      socket.to(`channel:${message.channelId}`).emit('message:reaction_updated', {
        messageId,
        reactions: formattedReactions
      });
      
      // Publish to Redis
      redis.publish('chatera:events', JSON.stringify({
        type: 'message:reaction_updated',
        roomId: `channel:${message.channelId}`,
        payload: {
          messageId,
          reactions: formattedReactions
        }
      }));
      
      // Return success
      callback?.({
        success: true,
        reactions: formattedReactions
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error removing reaction:', error);
      callback?.({
        success: false,
        error: 'Failed to remove reaction'
      });
    }
  });
  
  // Typing indicator
  socket.on('message:typing', async (data) => {
    try {
      const { channelId, isTyping } = data;
      
      // Broadcast typing status to channel
      socket.to(`channel:${channelId}`).emit('user:typing', {
        userId,
        channelId,
        isTyping
      });
      
      // Also publish to Redis
      redis.publish('chatera:events', JSON.stringify({
        type: 'user:typing',
        roomId: `channel:${channelId}`,
        payload: {
          userId,
          channelId,
          isTyping
        }
      }));
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error with typing indicator:', error);
    }
  });
  
  // Message read status
  socket.on('message:read', async (data, callback) => {
    try {
      const { channelId } = data;
      
      // Update user's last read timestamp
      await prisma.channelMember.update({
        where: {
          userId_channelId: {
            userId,
            channelId
          }
        },
        data: {
          lastRead: new Date()
        }
      });
      
      callback?.({
        success: true
      });
      
    } catch (error) {
      logger.error('[SOCKET:MESSAGE] Error updating read status:', error);
      callback?.({
        success: false,
        error: 'Failed to update read status'
      });
    }
  });
}

/**
 * Utility function to check if a user has a specific permission in a server
 */
async function checkServerPermission(
  userId: string,
  serverId: string,
  permission: string,
  prisma: PrismaClient
): Promise<boolean> {
  try {
    // Check if user is server owner (always has all permissions)
    const server = await prisma.server.findUnique({
      where: { id: serverId },
      select: { ownerId: true }
    });
    
    if (server?.ownerId === userId) {
      return true;
    }
    
    // Check user roles and their permissions
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          where: { serverId },
          select: { permissions: true }
        }
      }
    });
    
    // Check if any role has the required permission
    return userRoles.some(userRole => 
      userRole.role.permissions.includes(permission)
    );
    
  } catch (error) {
    logger.error('[PERMISSION] Error checking server permission:', error);
    return false;
  }
}
